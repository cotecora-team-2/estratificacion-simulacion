---
title: "Esquema de muestreo"
subtitle: "Chihuahua, Colima, Nayarit y Zacatecas"
author: "M. Anzarut, F. González, I. Meza, T. Ortiz"
output: word_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message=FALSE)
library(tidyverse)
library(devtools)
library(kableExtra)
library(furrr)
library(pander)

panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)

set.seed(6102)
# devtools::install_github("cotecora-team-2/quickcountmx")
library(quickcountmx)
theme_set(theme_minimal())
cb_palette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
```

```{r, echo=FALSE}
estados <- c("CHIH", "COL", "ZAC", "NAY")
partidos <- c("AMLO", "JAMK", "RAC", "CAND_IND_01", "CAND_IND_02", "CNR", "VN")
```



```{r cargar-datos, include = FALSE}
conteo_15 <- read_csv("../datos/conteo_15_inegi_10_sin_imputar.csv")
estratos_colapsado <- read_csv("../datos/reporte/estratos_colapsados_con_chih.csv") 
comp_15 <- conteo_15 %>%
  group_by(ID_ESTADO, ID_DISTRITO = ID_DTTO_FEDERAL_jul2020,
           SECCION = SECCION_jul2020) %>%
  summarise(comp_votos = mean(.fittedPC1)) %>%
  ungroup() %>% 
  mutate(SECCION = stringr::str_pad(SECCION, 4, pad = "0"))
# configuraciones
estratif_conf <- crossing(
         num_gpos_marginacion = c(1,2),
         num_gpos_ln = c(1,2), 
         num_gpos_votos = c(1, 2)) %>% 
  mutate(estratificacion_num = row_number()) %>% 
  transpose()
# computos distritales
conteo_2018_estados <- conteo_2018 %>% 
  filter(state_abbr %in% estados) %>% 
  group_by(state_abbr) %>% 
  left_join(comp_15)
conteo_2018_estados <- conteo_2018_estados %>% 
  group_by(ID_ESTADO, ID_DISTRITO) %>% 
  mutate(comp_votos = ifelse(is.na(comp_votos), mean(comp_votos, na.rm = TRUE),
                             comp_votos)) 
# preparar estratificaciones
marco_conf <- map_df(estratif_conf, function(x){
  num_gpos_marginacion <- x$num_gpos_marginacion
  num_gpos_ln <- x$num_gpos_ln
  num_gpos_votos <- x$num_gpos_votos
  estratificacion_num <- x$estratificacion_num
  marco <- conteo_2018_estados %>% 
  group_by(state_abbr) %>%
  mutate(estratificacion_num = estratificacion_num) %>% 
  mutate(indice_grupo = ntile(.fittedPC1, num_gpos_marginacion)) %>%
  mutate(indice_votos = ntile(comp_votos, num_gpos_votos)) %>%
  mutate(tam_ln = ntile(LISTA_NOMINAL_CASILLA, num_gpos_ln)) %>%
  mutate(estrato_df = interaction(ID_DISTRITO, indice_grupo, indice_votos, 
                                  tam_ln)) %>% 
  left_join(estratos_colapsado)
})

# Valores observados
estados_tbl <- conteo_2018 %>% select(NOMBRE_ESTADO, state_abbr) %>% unique
obs_tbl <-
  map_df(estados, function(estado){
    marco_estado <- marco_conf %>% 
      filter(state_abbr == estado, estratificacion_num == 1) 
    estratos_tbl <- marco_estado %>% group_by(estrato_df_colapsado) %>% count()
    total <- ratio_estimation(marco_estado, stratum = estrato_df_colapsado, 
                 data_stratum = estratos_tbl, 
                 n_stratum = n, parties = any_of(partidos), std_errors = FALSE)
    total$state_abbr <- estado
    total
  })
  
obs_tbl <- obs_tbl %>% rename(prop_obs = prop) %>% 
  left_join(estados_tbl)
#
estratos_tbl <- marco_conf %>% 
  group_by(state_abbr, indice_grupo, indice_votos, tam_ln, estratificacion_num, estrato_df_colapsado) %>% 
  count()
## cargar simulaciones
est_sin_censura <- readr::read_rds("../datos/reporte/estimaciones_sin_censura_reporte_solo_chih.rds") %>% left_join(obs_tbl)
est_con_censura <- readr::read_rds("../datos/reporte/estimaciones_con_censura_reporte_solo_chih.rds") %>% bind_rows() %>% left_join(obs_tbl)
est_sin_censura_sc <- readr::read_rds("../datos/reporte/estimaciones_sin_censura_reporte_sin_chih.rds") %>% left_join(obs_tbl)
est_con_censura_sc <- readr::read_rds("../datos/reporte/estimaciones_con_censura_reporte_sin_chih.rds") %>% bind_rows() %>% left_join(obs_tbl)
```

### Método  

El objetivo del conteo rápido es estimar la proporción de votos en favor de cada candidato. Para cumplir esto, se selecciona una muestra aleatoria de casillas del total y, con la muestra, se calculan intervalos del 95% de confianza para la proporción de votos de cada candidato. A continuación explicamos el criterio bajo el cuál se colectará dicha muestra aleatoria para Chihuahua, Nayarit, Zacatecas y Colima. 

El diseño muestral será estratificado en donde, al interior de cada estrato, se seleccionarán casillas mediante un muestreo aleatorio simple sin reemplazo. La asignación de muestra será proporcional al tamaño de cada estrato. Para definir los estratos a emplear:

1. Se crean distintas posibles estratificaciones a partir de cruces de algunas variables. 
2. Para cada estado, para cada una de las estratificaciones y para distintos tamaños de muestra, se simulan 200 muestras utilizando como marco la tabla de cómputos distritales del 2018. 
3. Con estas muestras se estiman los intervalos de 95% de confianza para la proporción de votos.
4. Se evalúan ciertos criterios con el fin de elegir la estratificación más conveniente. 

Los puntos importantes por definir entonces son: ¿Qué estratificaciones se evaluarán? ¿Qué tamaños de muestra se evaluarán? ¿Cómo se estimarán las proporciones de votos? ¿Con qué criterios decidiremos la estratificación óptima?

### Estratifiaciones evaluadas

Utilizamos cuatro variables para construir estratificaciones:

- Distrito federal dentro de cada estado.
- Índice de marginacion a nivel seccion (1 o 2 subgrupos): Esta variable se crea realizando un análisis de componentes principales con los datos del censo de población y vivienda del 2010 [1] y utilizando la primera componente, que se interpreta como un índice de marginación.
- Tamaño de lista nominal (1 o 2 subgrupos).
- Índice de votos en 2015 a nivel sección. (1 o 2 subgrupos): Esta variable se crea realizando un análisis de componentes principales con los datos de votación del 2015 y utilizando la primera componente. 

En cada estado, cruzamos el número de distritos federales con una de las siguientes configuraciones:

```{r, echo = FALSE}
tabla_estratos <- estratos_tbl %>% 
  rename(indice_marginacion = indice_grupo, lista_nominal = tam_ln) %>%  
  group_by(estratificacion_num) %>%
  summarise(across(all_of(c("indice_marginacion", "indice_votos", "lista_nominal")), ~ length(unique(.x)))) %>% 
  select(estratificacion_num, indice_marginacion, lista_nominal, indice_votos) 
pander(tabla_estratos)
```

Colapsamos algunos estratos del diseño para conseguir un mínimo de 60 casillas por estrato, usando las variables de la tabla anterior de derecha a izquierda y sin colapsar distritos federales. El corte de las variables en subgrupos se hace de forma que cada subgrupo tenga el número más similar de casillas posible.

### Tamaños de muestra evaluados

Mediante el muestreo probabilístico es posible definir estrategias de selección, tamaños de muestra y estimadores, para asegurar que la diferencia entre el estimador $\hat{p}$ y la verdadera proporción $p$ no difiera en valor absoluto en más de una cierta cantidad $d$ con un 95% de confianza. A la cantidad $d$ se le conoce como precisión. Las precisiones indican entonces el tamaño de los intervalos de confianza que presentaremos. 

El tamaño de muestra a elegir está directamente relacionado con el nivel de confianza que queremos obtener, las precisiones deseadas y el tamaño de la población total. Buscamos el tamaño mínimo de muestra que nos permita obtener intervalos del 95% de confianza con buenas precisiones. En cuanto a las poblaciones totales, el estado de Chihuahua, en las elecciones del 2018, tenía 5286 casillas, Colima tenía 950, Nayarit 1668 y Zacatecas 2508. Considerando ésto, para el estado de Chihuahua evaluaremos muestras del 4%, 6%, 8% y 10%, mientras que para los estados de Colima, Nayarit y Zacatecas, que tienen un número menor de casillas, evaluaremos muestras del 10%, 15%, 20%, 25% y 30%. Como las fracciones de muestreo consideradas para Chihuahua son distintas presentaremos su análisis por separado. 

```{r, echo = FALSE}
resumen_estados <- marco_conf %>% group_by(state_abbr) %>% 
  filter(estratificacion_num == 1) %>% 
  summarise(num_distritos_federales = length(unique(ID_DISTRITO)),
            num_casillas = n())
resumen_estados_tbl <- resumen_estados
names(resumen_estados_tbl) <- c("Estado", "# Distritos Fed", "# Casillas")
```

### Método de estimación

Sea $p_j$ la proporción de votos a favor del candidato $j$, para estimar $p_j$ utilizaremos el estimador de razón combinado $\hat p_j$, definido como:

$$ \hat p_j = \dfrac{\sum_{h=1}^L N_h \left(\frac{1}{n_h}\sum_{i=1}^{n_h} x_{hij} \right)}
{\sum_{j=1}^J \sum_{h=1}^L N_h \left(\frac{1}{n_h} \sum_{i=1}^{n_h} x_{hij} \right)}, $$

donde, para cada estrato $h$ , $n_h$ es el tamaño de la muestra, $N_h$ es el número total de casillas, $L$ es el número total de estratos, $J$ es el número total de candidatos (incluyendo nulos y no registrados) y $x_{hij}$ es el total de votos a favor del candidato $j$  en la casilla $i$.

El error estándar de este estimador se calcula utilizando bootrsap no paramétrico (ver, por ejemplo, [2]).


### Criterios de decisión

Entre más fina es una estratificación, mejor es la precisión. Sucede lo mismo con el tamaño de muestra, entre mayor es la muestra mejor es la precisión. Sin embargo, utilizar estratificaciones demasiado finas causa que hayan estratos con pocas casillas, que pueden no ser bien representados a la hora de muestrear. Por otro lado, el considerar muestras demasiado grandes implica un mayor porcentaje de capacitadores-asistentes electorales (CAE) con más de una casilla a reportar, esto complica el trabajo de los CAEs y puede resultar en que no reporten alguna de las casillas. Por esta razón, el diseño muestral evalúa en conjunto estos dos criterios, con el objetivo de encontrar un balance que maximice la precisión sin poner en riesgo la obtención de la muestra.


<!-- Evaluar la calibración implica corroborar que los intervalos producidos tienen una cobertura adecuada. En este caso, los intervalos se contruyen del 95% de confianza, por lo que corroboramos que contengan el porcentaje de votos verdadero aproximadamente el 95% del tiempo. -->

<!-- - Para censurar muestras por tiempo de llegada  -->
<!-- utilizamos **modelos de supervivencia** ajustados para datos de  -->
<!-- hora de llegada de información de 2018. [Reporte tiempos de llegada](https://sim-llegadas-3e5e7b.netlify.app/) -->
<!-- - Para muestras censuradas, colapsamos estratos vacíos dentro de distritos federales. -->

### Resultados para Colima, Nayarit y Zacatecas


```{r, echo = FALSE, message=FALSE, warning = FALSE}
fortificar <- function(datos, z = 2){
  datos %>%  
    mutate(estrat_num = factor(estratificacion_num)) %>% 
    mutate(precision = z * std_error, inf = prop - precision, 
           sup = prop + precision, 
           cubre = ifelse(prop_obs <= sup & prop_obs >= inf, 1, 0)) %>% 
    filter(party %in% c("AMLO", "JAMK", "RAC"))
    
}
ajustes_ancho <- tibble(prop_observada = c(0.7, 0.8, 0.9),
                        mult = c(1.4, 1.2, 1.00))
ajustes_ancho_chih <- tibble(prop_observada = c(0.7, 0.8, 0.9),
                        mult = c(1.55, 1.3, 1.15))
fortificar_ajustado <- function(datos, ajustes_ancho){
  datos %>%  
    left_join(ajustes_ancho) %>% 
    mutate(estrat_num = factor(estratificacion_num)) %>% 
    mutate(precision = mult * 2 * std_error, inf = prop - precision, 
           sup = prop + precision, 
           cubre = ifelse(prop_obs <= sup & prop_obs >= inf, 1, 0)) %>% 
    filter(party %in% c("AMLO", "JAMK", "RAC"))
    
}


resumir_sims <- function(datos){
  datos %>% group_by(NOMBRE_ESTADO, estrat_num, frac_m, prop_observada) %>% 
    summarise(precision_max = quantile(precision, 0.95), cobertura = mean(cubre),
              .groups = "drop")
}
resumir_sims_partido <- function(datos){
  datos %>% group_by(NOMBRE_ESTADO, party, estrat_num, frac_m, prop_observada) %>% 
    summarise(precision_max = quantile(precision, 0.95), cobertura = mean(cubre),
              .groups = "drop")
}
sin_censura_tbl <- est_sin_censura %>%
 mutate(prop_observada = 1) %>%
 fortificar %>%
 resumir_sims
sin_censura_partido_tbl <- est_sin_censura %>%
  mutate(prop_observada = 1) %>%
 fortificar %>%
 resumir_sims_partido
sin_censura_sc_tbl <- est_sin_censura_sc %>%
  mutate(prop_observada = 1) %>%
  fortificar %>%
  resumir_sims


con_censura_tbl <- est_con_censura %>%
  fortificar %>%
  resumir_sims
con_censura_partido_tbl <- est_con_censura %>%
  fortificar %>%
  resumir_sims_partido
con_censura_sc_tbl <- est_con_censura_sc %>%
  fortificar %>%
  resumir_sims
con_censura_partido_sc_tbl <- est_con_censura_sc %>%
  fortificar %>%
  resumir_sims_partido
con_censura_ajustado_tbl <- est_con_censura %>%
  fortificar_ajustado(ajustes_ancho) %>%
  resumir_sims
con_censura_ajustado_sc_tbl <- est_con_censura_sc %>%
  fortificar_ajustado(ajustes_ancho) %>%
  resumir_sims
con_censura_chih_ajustado_tbl <- est_con_censura %>%
  fortificar_ajustado(ajustes_ancho_chih) %>%
  resumir_sims()
```


A continuación tenemos una gráfica que muestra el cuantil 0.95 de las precisiones sobre los 4 candidatos mayores para cada estado, para distintos tamaños de muestreo y para cada estratifiación evaluada. La línea negra indica que el cuantil 0.95 de las precisiones es igual a  1.5, esto quiere decir que, bajo esa línea, el 95% de las muestras arrojaron intervalos con precisiones menores a 1.5. Un criterio conservador de selección es buscar fracciones de muestreo y estratificaciones que estén por debajo de la línea negra.

```{r, echo = FALSE, fig.width = 6, fig.height=3}
ggplot(sin_censura_sc_tbl, 
  aes(x = frac_m, y = precision_max, colour = estrat_num)) +
  geom_hline(yintercept = 1.5, colour = "gray20") + 
  geom_line() +
  geom_point() +
  facet_wrap(~NOMBRE_ESTADO) +
  scale_color_manual(values = cb_palette) +
  xlab("Fracción de muestreo") +
  ylab("Precisión") +
  labs(subtitle = "Cuantil 0.95 de precisión sobre 4 candidatos")
```


Notamos que para estos 3 estados la estratificación 6 tiene buena precisión, muy similar a la mejor precisión obtenida con la estratifiación 8 que es la más fina, por lo tanto se elige la estratifiación 6 para los 3 estados.

En cuanto a fracciones de muetreo tenemos que para Colima y Nayarit la fracción de 20% nos asegura estar bajo la línea negra, mientras que para Zacatecas basta tomar 15% con la estratificación 6. En la siguiente tabla mostramos el promedio de porcentaje de CAEs con 1, 2 y 3 casillas para la estratificación 6 y algunas fracciones de muestreo que parece razonable analizar:


```{r, echo = FALSE, warning = FALSE, message=FALSE, cache = TRUE}
marco_ext <- read_csv("../datos/reporte/marco_ext.csv") %>% 
  select(iD_ESTADO, CLAVE_CASILLA, ID_DISTRITO_FEDERAL, ID_AREA_RESPONSABILIDAD)

marco <- marco_ext %>% 
  mutate(cae = paste(iD_ESTADO, ID_DISTRITO_FEDERAL, ID_AREA_RESPONSABILIDAD, 
                     sep = "-")) %>% 
  select(CLAVE_CASILLA, cae) 

marco_caes <- marco_conf %>% 
  filter(state_abbr != "CHIH", estratificacion_num == 1) %>% 
  left_join(distinct(marco), by = "CLAVE_CASILLA") %>% 
  mutate(estrato = paste(state_abbr, estrato_df_colapsado))

simular_caes <- function(frac_m){
  muestra <- select_sample_prop(marco_caes, stratum = estrato, frac = frac_m)
  muestra %>% 
    count(state_abbr, cae) %>% 
    group_by(state_abbr, n) %>% 
    summarise(n_casos = n(), .groups = "drop") %>% 
    group_by(state_abbr) %>% 
    mutate(prop_casos = 100 * n_casos / sum(n_casos)) %>% 
    ungroup()
}


replicar_sims <- function(frac_m = 0.15, runs = 200){
  sims <- rerun(runs, simular_caes(frac_m = frac_m)) %>% 
    set_names(., 1:runs) %>% 
    bind_rows(.id = "run") 
  sims %>% 
    complete(n, nesting(state_abbr, run), fill = list(prop_casos = 0)) %>% 
    group_by(state_abbr, n) %>% 
    summarise(media_porc = round(mean(prop_casos)), 
              sd_porc = round(sd(prop_casos)), .groups = "drop") %>% 
    na.omit()
}
sims_porc <- map_df(set_names(c(0.15, 0.20, 0.25)), replicar_sims, .id = "frac")
```


```{r, echo = FALSE, warning = FALSE, message=FALSE}
tab_cae_sc <- sims_porc %>% 
  select(-sd_porc) %>% 
  filter(n < 4) %>% 
  pivot_wider(names_from = n, values_from = media_porc) %>% 
  arrange(state_abbr, frac) %>% 
  select(state_abbr, everything()) %>% 
  rename(Estado = state_abbr, frac_muestreo = frac) 
pander(tab_cae_sc)
```


El número de CAEs con 1, 2 y 3 casillas parece razonable para fracciones de muestreo de 20% para Colima y Nayarit y 15% para Zacatecas, por lo que confirmamos ésta elección.




## Resultados para Chihuahua

En Chihuahua observamos un patrón similar en cuánto a precisión:

```{r, echo = FALSE, fig.width = 6, fig.height=3}
ggplot(sin_censura_tbl %>% filter(prop_observada == 1) %>% 
         filter(NOMBRE_ESTADO=="CHIHUAHUA"), 
  aes(x = frac_m, y = precision_max, colour = estrat_num)) +
  geom_hline(yintercept = 1.5, colour = "gray20") + 
  geom_line() +
  geom_point() +
  facet_wrap(~NOMBRE_ESTADO) +
  scale_color_manual(values = cb_palette) +
  xlab("Fracción de muestreo") +
  ylab("Precisión") +
  scale_x_continuous(breaks = c(0.04, 0.06, 0.08, 0.1)) +
  labs(subtitle = "Cuantil 0.95 de precisión sobre 4 candidatos")
```

En éste caso, como las fracciones de muestreo consideradas son mucho menores, el porcentaje de casos con 1, 2 y 3 casillas es razonable para cualquiera de éstas fracciones. 

```{r, message=FALSE, warning = FALSE, echo=FALSE}
marco_caes_ch <- marco_conf %>% 
  filter(state_abbr == "CHIH", estratificacion_num == 1) %>% 
  left_join(distinct(marco), by = "CLAVE_CASILLA") %>% 
  mutate(estrato = paste(state_abbr, estrato_df_colapsado))

simular_caes_ch <- function(frac_m){
  muestra <- select_sample_prop(marco_caes_ch, stratum = estrato, frac = frac_m)
  muestra %>% 
    count(state_abbr, cae) %>% 
    group_by(state_abbr, n) %>% 
    summarise(n_casos = n(), .groups = "drop") %>% 
    group_by(state_abbr) %>% 
    mutate(prop_casos = 100 * n_casos / sum(n_casos)) %>% 
    ungroup()
}


replicar_sims_ch <- function(frac_m = 0.5, runs = 200){
  sims <- rerun(runs, simular_caes_ch(frac_m = frac_m)) %>% 
    set_names(., 1:runs) %>% 
    bind_rows(.id = "run") 
  sims %>% 
    complete(n, nesting(state_abbr, run), fill = list(prop_casos = 0)) %>% 
    group_by(state_abbr, n) %>% 
    summarise(media_porc = round(mean(prop_casos)), 
              sd_porc = round(sd(prop_casos)), .groups = "drop") %>% 
    na.omit()
}
sims_porc_ch <- map_df(set_names(c(0.04, 0.06, 0.08, 0.1)), replicar_sims_ch, .id = "frac")
```


```{r, echo = FALSE, warning = FALSE, message=FALSE}
tab_cae_ch <- sims_porc_ch %>% 
  select(-sd_porc) %>% 
  filter(n < 4) %>% 
  pivot_wider(names_from = n, values_from = media_porc) %>% 
  arrange(state_abbr, frac) %>% 
  select(state_abbr, everything()) %>% 
  rename(Estado = state_abbr, frac_muestreo = frac) 
pander(tab_cae_ch)
```

Elegimos utilizar la estratificación número 3 con una fracción de muestreo de 6%.  

## Diseño final 

Para el estado de Chihuahua se elige la estratificación 3 que cruza los distritos federales con 2 niveles de lista nominal. Para los estados de Colima, Nayarit y Zacatecas se elige la estratificación 6 que cruza los distritos federales con 2 niveles de índice de marginación y 2 niveles de índice de votos. A continuación aparece el diseño muestral final.

```{r, message=FALSE, warning = FALSE, echo=FALSE}
num_estratos_tbl <- marco_conf %>% group_by(NOMBRE_ESTADO, estratificacion_num, estrato_df_colapsado) %>% 
  tally() %>% 
  filter(estratificacion_num == 6, NOMBRE_ESTADO!="CHIHUAHUA") %>% 
  group_by(NOMBRE_ESTADO) %>% summarise(num_estratos = n())

frac_seleccionadas <- tibble(NOMBRE_ESTADO =  c("ZACATECAS", "COLIMA", "NAYARIT"),
                    frac_m = c(0.15, 0.20, 0.20))
tab_sc <- sin_censura_sc_tbl %>% 
  filter(estrat_num == 6) %>% 
  inner_join(frac_seleccionadas) %>% 
  select(NOMBRE_ESTADO, frac_m) %>% 
  left_join(resumen_estados %>% left_join(estados_tbl)) %>% 
  mutate(n = frac_m * num_casillas) %>% 
  select(NOMBRE_ESTADO, frac_m, n) %>% 
  left_join(num_estratos_tbl) %>% 
  mutate(n_muestra = round(n)) %>% 
  rename(Estado = NOMBRE_ESTADO) %>%
  rename(Fracción_muestreo = frac_m) %>%
  rename(Tamaño_muestra = n_muestra) %>%
  rename(Número_estratos = num_estratos) %>%
  select(Estado, Fracción_muestreo, Número_estratos, Tamaño_muestra)  

num_estratos_tbl_ch <- marco_conf %>% group_by(NOMBRE_ESTADO, estratificacion_num, estrato_df_colapsado) %>% 
  tally() %>% 
  filter(estratificacion_num == 3, NOMBRE_ESTADO =="CHIHUAHUA") %>% 
  group_by(NOMBRE_ESTADO) %>% summarise(num_estratos = n())

tab_ch <- sin_censura_tbl %>% 
  filter(estrat_num == 3) %>% 
  filter(frac_m == 0.06) %>% 
  select(NOMBRE_ESTADO, frac_m) %>% 
  left_join(resumen_estados %>% left_join(estados_tbl)) %>% 
  mutate(n = frac_m * num_casillas) %>% 
  select(NOMBRE_ESTADO, frac_m, n) %>% 
  left_join(num_estratos_tbl_ch) %>% 
  mutate(n_muestra = round(n)) %>% 
  rename(Estado = NOMBRE_ESTADO) %>%
  rename(Fracción_muestreo = frac_m) %>%
  rename(Tamaño_muestra = n_muestra) %>%
  rename(Número_estratos = num_estratos) %>%
  select(Estado, Fracción_muestreo, Número_estratos, Tamaño_muestra)

rbind(tab_ch, tab_sc) %>% 
  pander()

```

### Referencias

[1] http://gaia.inegi.org.mx/geoelectoral

[2] https://tereom.github.io/est_computacional/05-Bootsrap.html


